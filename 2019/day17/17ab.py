s=[
'..................#######................................',
'..................#.....#................................',
'..................#.....#................................',
'..................#.....#................................',
'..................#.....#................................',
'..................#.....#................................',
'..................#.....#................................',
'..................#.....#................................',
'..................##########^...................#########',
'........................#.......................#.......#',
'........................#############...........#.......#',
'....................................#...........#.......#',
'....................................#...........#.......#',
'....................................#...........#.......#',
'....................................#.........###########',
'....................................#.........#.#........',
'....................................#.........#.#........',
'....................................#.........#.#........',
'....................................#############........',
'..............................................#..........',
'..............................................#..........',
'..............................................#..........',
'..............................................#..........',
'..............................................#..........',
'..............................................#..........',
'..............................................#..........',
'......................................#########..........',
'......................................#..................',
'......................................#..................',
'......................................#..................',
'......................................#..................',
'......................................#..................',
'......................................#..................',
'......................................#..................',
'..........#########...................#..................',
'..........#.......#...................#..................',
'..........#.......#...................#..................',
'..........#.......#...................#..................',
'..........#.......#...................###########........',
'..........#.......#.............................#........',
'........#############.#.........................#........',
'........#.#.......#.#.#.........................#........',
'........#.#.......###########...................#........',
'........#.#.........#.#.....#...................#........',
'###########.........#.#.....#...................#........',
'#.......#...........#.#.....#...................#........',
'#.......#...........#.#.....#...........#########........',
'#.......#...........#.#.....#...........#................',
'#.......#...........#############.......#................',
'#.......#.............#.....#...#.......#................',
'#########.............#######...#.......#................',
'................................#.......#................',
'................................#.......#................',
'................................#.......#................',
'................................#.......#................',
'................................#.......#................',
'................................#########................',
]

n = 0
intersec = set()
for y in range(1,len(s)-1) : 
	for x in range(1,len(s[0])-1) : 
		if s[y][x]==s[y+1][x]==s[y-1][x]==s[y][x-1]==s[y][x+1]=='#' : 
			intersec.add((x,y))
		if s[y][x] == '^' : sx=x;sy=y
		if s[y][x] == '#' : n+=1


# A : interdections
print(sum(x*y for x,y in intersec))
print(n)

# B 
L = (-1,0)
R = (1,0)
U = (0,-1)
D = (0,1)
turn_left  = { L:D,R:U,U:L,D:R }
turn_right = { L:U,R:D,U:R,D:L }

def inpath(x,y) : 
	try :
		return s[y][x]=='#'
	except IndexError : 
		return False

def path(sofar,x,y,dir) : 
	# avance
	n=0
	try : 
		while True : 
			n += 1
			px,py = x,y
			x += dir[0]
			y += dir[1]
			if (x,y) in intersec : print('intersec en',x,y)
			if not inpath(x,y) : break # turn
	except IndexError : 
		pass # out of bound, also stop
	n -= 1 ; x,y=px,py
	sofar.append(str(n))

	# turn left ?
	ndir = turn_left[dir]
	if inpath(x+ndir[0],y+ndir[1]): 
		sofar.append('L')
		return path(sofar[:],x,y,ndir)
	else : 
		ndir = turn_right[dir]
		if inpath(x+ndir[0],y+ndir[1]) : 
			sofar.append('R')
			return path(sofar[:],x,y,ndir)
		else : 
			# the end
			return sofar
	

	
# B: start at sx,sy, position
print(sx,sy)
pa = path(['L'],sx,sy,(-1,0))
print(pa)
# find A,B and C : 3 lengths
for lena in range(2,10,2) :
	for skipb in range(0,len(pa)-lena,2):
		for lenb in range(2,10,2) : 
			for skipc in range(0,len(pa)-lena-lenb,2) :				
				for lenc in range(2,10,2) :
					A = pa[:lena]
					B = pa[lena+skipb:lena+skipb+lenb]
					C = pa[lena+skipb+lenb+skipc:lena+skipb+lenb+skipc+lenc]
					if not C : continue
					#print('--------',A,B,C)

					# try to match with only A,B or C 
					remains = pa[:]
					path = ''
					while remains : 
						for X,x in zip((A,B,C),'ABC') : 
							if remains[:len(X)]==X : 
								remains = remains[len(X):]
								path += x
								break
						else : # no break, not found for a, b or c
							break
					if not remains : # found a solution
						print (path,A,B,C,lena,skipb,lenb,skipc,lenc)


